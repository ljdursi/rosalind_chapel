module CHBP {
  // Character-Based Phylogen
  // http://rosalind.info/problems/chbp/
  const defaultfilename="none";
  config const infile=defaultfilename;

  const empty_set: domain(string);

  // use stdin if filename == defaultfilename
  iter lines_from_file(filename: string, defaultfilename: string) throws {
    var channel = stdin;

    if infile != defaultfilename {
      var file = open(infile, iomode.r);
      channel = file.reader();
    }

    var line: string;
    while (channel.readline(line)) do
      yield line.strip();
  }


  class Partition {
    // A partition of a list of labels, generated by either a set of labels
    // or a charactable entry (a string of labels.size 0s and 1s)
    var set, complement: domain(string);

    proc init(labels, char_table_line:string) {
      const universe : domain(string) = labels;
      set = empty_set; // this is absurd but I don't see how else to initialize the empty set.

      for (i, char) in zip(1.., char_table_line) do
        if char == '0' then
          set.add(labels[i]);
      complement = universe - set;
    }

    proc init(labels, set_labels) {
      const universe : domain(string) = labels;
      set = empty_set; // this is absurd but I don't see how else to initialize the empty set.

      set.add(set_labels);
      complement = universe - set;
    }

    proc size_diff() {
      return abs(set.size - complement.size);
    }

    proc contains_null() {
      return (set.size == 0) || (complement.size == 0);
    }

    proc intersections(other) {
      return [set & other.set, set & other.complement,
              complement & other.set, complement & other.complement];
    }

    proc consistent_with(other) {
      const overlaps = for ins in intersections(other) do if ins.size == 0 then ins.size;
      return overlaps.size != 0;
    }

    proc subdivides(labels) {
      // Does this partition divide the labels provided?
      const set_overlap = set & labels;

      if ((set_overlap.size == 0) || (set_overlap.size == labels.size)) then
        return false;

      return true;
    }

    proc as_character_table(labels) {
      var line = "";
      for lab in labels do
        if set.member(lab) then
          line += "0";
        else
          line += "1";

      return line;
    }

  }


  proc split_list(labels) {
    // returns the list split as evenly into two as possible
    const len_l = labels.size;

    var left = labels[1..(len_l+1)/2];
    return left;
  }


  class Tree {
    // Create a binary tree from a set of partitions of its leafs
    var is_root: bool;
    var name = "";
    var children: [1..0] Tree;

    proc build_tree(partitions:[?] Partition, leafs:[?] string, is_root=false) {
      this.is_root = is_root;

      if leafs.size == 1 {
        name = leafs[1];
        return;
      }

      // if not a leaf, there's no name
      name = "";

      if (partitions.size == 0) {
        // if there's no partitions provided, just invent one arbitrarily
        var left = split_list(leafs);
        partitions.push_back(new unmanaged Partition(leafs, set_labels=left));
      }

      // Choose the most evenly-split partition
      const part_sizes = [i in 1..partitions.size] partitions[i].size_diff();
      const (min_size, min_idx) = minloc reduce zip(part_sizes, part_sizes.domain);

      const leafset : domain(string) = leafs;
      const min_p = partitions[min_idx];
      const (leftset, rightset) = (min_p.set & leafset, min_p.complement & leafset);

      // make sure any subtrees generated are consistent with remaining partitions
      var left_partitions: [1..0] Partition;
      var right_partitions: [1..0] Partition;

      for p in partitions {
        if p.contains_null() || p == min_p then
          continue;

        var nsets = 0;
        if p.subdivides(leftset) {
          left_partitions.push_back(p);
          nsets += 1;
        }
        if p.subdivides(rightset) {
          right_partitions.push_back(p);
          nsets += 1;
        }

        // if there are partitions that divide *both* subsets, 
        // there's an inconsistent partition somewhere - explode.
        assert(nsets != 2);
      }

      // create the subtrees
      var left_leafs : [1..0] string;
      var right_leafs : [1..0] string;
      for item in leftset do
        left_leafs.push_back(item);
      for item in rightset do
        right_leafs.push_back(item);

      if (left_leafs.size > 0) {
        children.push_back(new unmanaged Tree()); 
        children[1].build_tree(left_partitions, left_leafs);
      }

      if (right_leafs.size > 0) {
        children.push_back(new unmanaged Tree());
        children[children.size].build_tree(right_partitions, right_leafs);
      }

      // if we're the root, we're allowed 3 children - take apart a child if we can
      if (is_root) {
        for (idx, child) in zip(1..children.size, children) {
          if child.children.size == 2 {
            children.push_back(child.children[1]);
            children.push_back(child.children[2]);
            children.remove(idx);
            break;
          }
        }
      }
    }

    proc newick() : string {
     var subtreestr = "";
     const nchildren = children.size;

     if (nchildren > 0) {
       subtreestr += "(";

       for i in 1..nchildren-1 do
         subtreestr += children[i].newick() + ",";

       subtreestr += children[nchildren].newick() + ")";
      }

      if (name != "") then
        subtreestr += name;

      return subtreestr;
    }
  }


  proc main() {
    try! {
      const lines = lines_from_file(infile, defaultfilename);
      const labels = lines[1].split();
      const characters = lines[2..];

      const n = characters.size;
      var partitions : [1..0] Partition;
      for ch in characters do
        partitions.push_back(new unmanaged Partition(labels, char_table_line = ch));

      var phylogeny = new owned Tree();
      phylogeny.build_tree(partitions, labels, true);
      writeln(phylogeny.newick(), ";");
    }
  }
}
