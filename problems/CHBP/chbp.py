#!/usr/bin/env python
# pylint: disable=W1401
# pylint: disable=C0103
# Character-Based Phylogeny
# http://rosalind.info/problems/chbp/
from __future__ import print_function
import argparse
import sys


class Partition(object):
    # A partition of a list of labels, generated by a set of labels
    # or a character table entry (line of 0s and 1s)
    def __init__(self, labels, char_table_line=None, setlabels=None):
        universe = set(labels)

        if char_table_line:
            item_labels = [int(c) for c in char_table_line]
            items = [labels[idx] for idx, char in enumerate(item_labels) if char == 0]
        else:
            items = setlabels

        self._set = set(items)
        self._complement = set(list(universe - set(self._set)))

    def size_diff(self):
        return abs(len(self._set) - len(self._complement))

    def contains_null(self):
        return len(self._set) == 0 or len(self._complement) == 0

    def __str__(self):
        return "{" + ", ".join(self._set) + "} | {" + ", ".join(self._complement) + "}"

    def __hash__(self):
        return hash(str(self))

    def __eq__(self, other):
        if not isinstance(other, Partition):
            return False
        return self.__hash__() == hash(other)

    def intersections(self, other):
        s1, s1_c = self.set, self.complement
        s2, s2_c  = other.set, other.complement

        return (s1.intersection(s2), s1.intersection(s2_c),
                s1_c.intersection(s2), s1_c.intersection(s2_c))

    def consistent_with(self, other):
        empty = [len(intersection) == 0 for intersection in self.intersections(other)]
        return any(empty)

    @property
    def set(self):
        return self._set

    @property
    def complement(self):
        return self._complement

    def subdivides(self, labels):
        # Does this partition divide the labels provided?
        labelset = set(labels)
        set_overlap = set(self._set).intersection(labelset)
        if len(set_overlap) in [0, len(labelset)]:
            return False

        return True


def split_list(labels):
    # Returns the list split as evenly into two halves as possible
    l = list(labels)
    len_l = len(l)
    left = l[0:(len_l+1)//2]
    right = l[(len_l+1)//2:]
    return left, right


class Tree(object):
    # Create a binary tree from a set of partitions of its leafs
    def __init__(self, partitions, leafs, parent=None):
        self._children = []
        self._parent = parent
        self._name = ""

        assert leafs

        if len(leafs) == 1:
            self._name = leafs.pop()
            return

        # if there's no partitions provided, just invent one arbitrarily
        if not partitions:
            partitions = set([Partition(leafs, setlabels=split_list(leafs)[0])])

        # Choose the most even-split partition
        min_p = min(partitions, key=lambda x: x.size_diff())
        left, right = min_p.set.intersection(leafs), min_p.complement.intersection(leafs)

        # Make sure any subtrees generated are consistent with remaining partitions
        left_partitions = set()
        right_partitions = set()
        for p in partitions:
            if p.subdivides(left):
                left_partitions.add(p)
            if p.subdivides(right):
                right_partitions.add(p)

        # if there are partitions that divide *both* subsets, 
        # there's an inconsistent partition somewhere - explode.
        assert not left_partitions.intersection(right_partitions) 

        # create the subtrees
        if left:
            self._children.append(Tree(left_partitions, left, self))
        if right:
            self._children.append(Tree(right_partitions, right, self))

        # if we're the root, we're allowed 3 children - take apart a child if we can
        if not parent:
            if self._children[0] and self._children[0].nchildren == 2:
                self._children = self._children[0].children() + [self._children[1]]
            elif self._children[1] and self._children[1].nchildren == 2:
                self._children = [self._children[0]] + self._children[1].children()


    @property
    def name(self):
        return self._name

    def nchildren(self):
        return len(self._children)

    def children(self):
        return self._children

    def newick(self):
        subtreestr = ""
        if self._children:
            subtreestr = "(" + ",".join([child.newick() for child in self._children]) + ")"

        if self._name != "":
            subtreestr += self._name

        return subtreestr


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),
                        default=sys.stdin)
    args = parser.parse_args()

    with args.infile as f:
        lines = [line.strip() for line in f.readlines()]
        labels = lines[0].split()
        partitions = [Partition(labels, char_table_line=l) for l in lines[1:]]
        partitions = set([p for p in partitions if not p.contains_null()])

    phylogeny = Tree(partitions, set(labels))
    print(phylogeny.newick() + ";")


if __name__ == "__main__":
    main()
