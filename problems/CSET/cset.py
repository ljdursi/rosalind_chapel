#!/usr/bin/env python
# pylint: disable=W1401
# pylint: disable=C0103
# Fixing an Inconsistent Character Set
# http://rosalind.info/problems/cset/
from __future__ import print_function
import argparse
import sys
import numpy


class Partition(object):
    # A partition of a list of labels, generated by a set of labels
    # or a character table entry (line of 0s and 1s)
    def __init__(self, labels, char_table_line=None, setlabels=None):
        universe = set(labels)

        if char_table_line:
            item_labels = [int(c) for c in char_table_line]
            items = [labels[idx] for idx, char in enumerate(item_labels) if char == 0]
        else:
            items = setlabels

        self._set = set(items)
        self._complement = set(list(universe - set(self._set)))

    def size_diff(self):
        return abs(len(self._set) - len(self._complement))

    def contains_null(self):
        return len(self._set) == 0 or len(self._complement) == 0

    def __str__(self):
        return "{" + ", ".join(self._set) + "} | {" + ", ".join(self._complement) + "}"

    def __hash__(self):
        return hash(str(self))

    def __eq__(self, other):
        if not isinstance(other, Partition):
            return False
        return self.__hash__() == hash(other)

    def intersections(self, other):
        s1, s1_c = self.set, self.complement
        s2, s2_c  = other.set, other.complement

        return (s1.intersection(s2), s1.intersection(s2_c),
                s1_c.intersection(s2), s1_c.intersection(s2_c))

    def consistent_with(self, other):
        empty = [len(intersection) == 0 for intersection in self.intersections(other)]
        return any(empty)

    @property
    def set(self):
        return self._set

    @property
    def complement(self):
        return self._complement

    def subdivides(self, labels):
        # Does this partition divide the labels provided?
        labelset = set(labels)
        set_overlap = set(self._set).intersection(labelset)
        if len(set_overlap) in [0, len(labelset)]:
            return False

        return True

    def as_character_table(self, labels):
        line = ""
        for lab in labels:
            newchar = "0" if lab in self._set else "1"
            line += newchar

        return line


def consistency_matrix(partitions):
    n = len(partitions)
    consistency = numpy.ones((n, n), dtype=numpy.bool)

    for i, p in enumerate(partitions):
        for j, q in zip(range(i+1, n), partitions[i+1:n]):
            consistency[i, j] = p.consistent_with(q)
            consistency[j, i] = consistency[i, j]

    return consistency


def worst_offender(consistency, n):
    ninconsistent = numpy.sum(consistency, axis=1)
    ninconsistent = n - ninconsistent
    worst = numpy.argmax(ninconsistent)
    return (ninconsistent[worst], worst)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),
                        default=sys.stdin)
    args = parser.parse_args()

    with args.infile as f:
        lines = [line.strip() for line in f.readlines()]
        n = len(lines)
        nlabels = len(lines[0])
        labels = [str(i) for i in range(nlabels)]
        partitions = [Partition(labels, char_table_line=l) for l in lines]
        partitions = list(set([p for p in partitions if not p.contains_null()]))

    worstscore = 100
    while worstscore > 0:
       consistency = consistency_matrix(partitions) 
       worstscore, worst = worst_offender(consistency, n)

       if worstscore > 0:
           del partitions[worst]
           n -= 1

    for p in partitions:
        print(p.as_character_table(labels))


if __name__ == "__main__":
    main()
